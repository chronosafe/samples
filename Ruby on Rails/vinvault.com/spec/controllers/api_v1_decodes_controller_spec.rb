require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

describe API::V1::DecodesController do
  include Devise::TestHelpers

  before(:all) do
    load "#{Rails.root}/db/seeds.rb"
  end

  before(:each) do
    Decode.destroy_all
    DecoderLog.destroy_all
    VehicleCache.destroy_all
    Vehicle.destroy_all
    Pattern.destroy_all
    Pattern.create(value: '1D7RB1CT A')
    Pattern.create(value: '1D7RB1CT B')
    Vehicle.create(pattern_id: Pattern.first.id, trim: 'Deluxe')

    #@user = FactoryGirl.create(:admin)
  end

  #after(:each) do
  #  Decode.destroy_all
  #end

  # This should return the minimal set of attributes required to create a valid
  # Decode. As you add validations to Decode, be sure to
  # adjust the attributes here as well.
  let(:valid_attributes)   { { vin: '1D7RB1CT8AS203937' } }
  let(:invalid_attributes) { { invalid: nil } }

  # This should return the minimal set of values that should be in the session
  # in order to pass any filters (e.g. authentication) defined in
  # DecodesController. Be sure to keep this updated too.
  let(:valid_session) { { vin: '1D7RB1CT8AS203937', auth_token: 'QvjAbAQBwhxvzbCF3tmp'} }
  let(:invalid_session) { { auth_token: '4vjNVNQBwhxvzbCF9way'} }

  let(:admin_auth)    {{ auth_token: '4vjNVNQBwhxvzbCF9way'}}
  let(:bronze_auth)   {{ auth_token: 'QvjAbAQBwhxvzbCF9tmp'}}
  let(:silver_auth)   {{ auth_token: 'QvjAbAQBwhxvzbCF1tmp'}}
  let(:gold_auth)     {{ auth_token: 'QvjAbAQBwhxvzbCF2tmp'}}
  let(:platinum_auth) {{ auth_token: 'QvjAbAQBwhxvzbCF3tmp'}}

  let(:bronze_session)   { { vin: '1D7RB1CT8AS203937', auth_token: 'QvjAbAQBwhxvzbCF9tmp', format: 'json'} }
  let(:silver_session)   { { vin: '1D7RB1CT8AS203937', auth_token: 'QvjAbAQBwhxvzbCF1tmp', format: 'json'} }
  let(:gold_session)     { { vin: '1D7RB1CT8AS203937', auth_token: 'QvjAbAQBwhxvzbCF2tmp', format: 'json'} }
  let(:platinum_session) { { vin: '1D7RB1CT8AS203937', auth_token: 'QvjAbAQBwhxvzbCF3tmp', format: 'json'} }
  let(:admin_session)    { { vin: '1D7RB1CT8AS203937', auth_token: '4vjNVNQBwhxvzbCF9way', format: 'json'} }
  let(:expired_session)  { { vin: '1D7RB1CT8AS203937', auth_token: '9vjAb3cwhx5zbCF9000',  format: 'json'}}


  let(:bronze_invalid_session)   { { vin: '1D7RB1CT8AS203937', auth_token: '1', format: 'json'} }
  let(:silver_invalid_session)   { { vin: '1D7RB1CT8AS203937', auth_token: '1', format: 'json'} }
  let(:gold_invalid_session)     { { vin: '1D7RB1CT8AS203937', auth_token: '1', format: 'json'} }
  let(:platinum_invalid_session) { { vin: '1D7RB1CT8AS203937', auth_token: '1', format: 'json'} }
  let(:admin_invalid_session)    { { vin: '1D7RB1CT8AS203937', auth_token: '1', format: 'json'} }

  let(:bronze_invalid_vin)   { { vin: '1', auth_token: 'QvjAbAQBwhxvzbCF9tmp', format: 'json'} }
  let(:silver_invalid_vin)   { { vin: '2', auth_token: 'QvjAbAQBwhxvzbCF1tmp', format: 'json'} }
  let(:gold_invalid_vin)     { { vin: '3', auth_token: 'QvjAbAQBwhxvzbCF2tmp', format: 'json'} }
  let(:platinum_invalid_vin) { { vin: '1111B1CT8AS203937', auth_token: 'QvjAbAQBwhxvzbCF3tmp', format: 'json'} }
  let(:admin_invalid_vin)    { { vin: '33', auth_token: '4vjNVNQBwhxvzbCF9way', format: 'json'} }

  let(:classic_valid_vin)    { { vin: '9T02M123456', auth_token: '4vjNVNQBwhxvzbCF9way', format: 'json' }}
  let(:classic_invalid_vin)  { { vin: 'A2345550000', auth_token: '4vjNVNQBwhxvzbCF9way', format: 'json' }}

  #describe 'HTTP Get will fire the show action if a auth_token is passed' do
  #  it 'rejects get requests that do not have an auth_token set' do
  #    post :basic, bronze_session
  #    get :show, {id: Decode.last.id}
  #    expect(response.status).to be(403)
  #  end
  #end


  describe 'Classic VINs' do
    before(:all) do
      ClassicPattern.destroy_all
      ClassicVehicle.destroy_all
      FactoryGirl.create(:classic_pattern)
      FactoryGirl.create(:classic_vehicle)
    end

    after(:all) do
      ClassicPattern.destroy_all
      ClassicVehicle.destroy_all
    end
    it 'should create a decode for a valid classic VIN' do
      post :create, classic_valid_vin
      puts "response: #{response.body}"
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      Decode.first.successful.should be_true
    end

    it 'should not create a decode for an invalid classic VIN' do
      post :create, classic_invalid_vin
      expect(response.status).to be(404)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      Decode.first.successful.should be_false
    end
  end

  describe 'Expired account' do
    it 'should not allow access if the account is expired' do
      post :create, expired_session
      expect(response.status).to be(403)
      response.body.should start_with('Your account is no longer active.')
    end

  end

  describe 'VehicleCache creation' do
    # NOTE: Bypasses the cache since it uses only limited data
    it 'should not create a vehicle cache for version 1 (Basic)' do
      post :create, bronze_session.merge( :format => 'xml' )
      VehicleCache.count.should be(0)
    end

    it 'should create a vehicle cache for version 1 (Advanced)' do
      post :create, platinum_session.merge( :format => 'xml' )
      VehicleCache.count.should be(1)
      cached = VehicleCache.first
      cached.version.should be(1)
      cached.value.should start_with('<trim')
      cached.value.should include('Deluxe')
    end
  end

  describe 'Data formats (Basic)' do
    it 'responds with XML when format is .xml' do
      post :create, bronze_session.merge( :format => 'xml' )
      response.body.should start_with('<decode api')
      expect(response.status).to be(201)
    end
    it 'responds with XML when format is .xml' do
      post :create, platinum_session.merge( :format => 'xml', :type => 1 )
      response.body.should start_with('<decode api')
      expect(response.status).to be(201)
    end

    it 'responds with JSON when format is .json' do
      post :create, bronze_session.merge( :format => 'json' )
      response.body.should start_with("{\"decode\":{\"api\"")
      expect(response.status).to be(201)
    end
    it 'responds with JSON when format is .json' do
      post :create, platinum_session.merge( :format => 'json', :type => 1 )
      response.body.should start_with("{\"decode\":{\"api\"")
      expect(response.status).to be(201)
    end

    it 'responds with JSON when format is .js' do
      post :create, bronze_session.merge( :format => 'js', :callback => 'func_call' )
      response.body.should start_with("func_call({\"decode\":{\"api\"")
      expect(response.status).to be(201)
    end
    it 'responds with JSON when format is .js' do
      post :create, platinum_session.merge( :format => 'js', :callback => 'func_call', :type => 1 )
      response.body.should start_with("func_call({\"decode\":{\"api\"")
      expect(response.status).to be(201)
    end
  end

  describe 'Data formats (Advanced)' do
    it 'responds with XML when format is .xml' do
      post :create, bronze_session.merge( :format => 'xml', :type => 2 )
      response.body.should start_with('Authorization failure')
      expect(response.status).to be(401)
    end
    it 'responds with XML when format is .xml' do
      post :create, platinum_session.merge( :format => 'xml' )
      response.body.should start_with('<decode api')
      expect(response.status).to be(201)
    end

    it 'responds with JSON when format is .json' do
      post :create, bronze_session.merge( :format => 'json', :type => 2 )
      response.body.should start_with('Authorization failure')
      expect(response.status).to be(401)
    end
    it 'responds with JSON when format is .json' do
      post :create, platinum_session.merge( :format => 'json' )
      response.body.should start_with("{\"decode\":{\"api\"")
      expect(response.status).to be(201)
    end

    it 'responds with JSON when format is .js' do
      post :create, bronze_session.merge( :format => 'js', :callback => 'func_call', :type => 2 )
      response.body.should start_with('Authorization failure')
      expect(response.status).to be(401)
    end
    it 'responds with JSON when format is .js' do
      post :create, platinum_session.merge( :format => 'js', :callback => 'func_call' )
      response.body.should start_with("func_call({\"decode\":{\"api\"")
      expect(response.status).to be(201)
    end
  end

  describe 'Invalid Session' do
    it 'should create a basic Decode for an invalid session' do
      post :create, invalid_session
      expect(response.status).to be(404)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end

    it 'should create a decode for a Advanced decode type' do
      post :create, invalid_session
      expect(response.status).to be(404)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end
  end

  describe 'Admin User' do

    it 'should create a basic Decode for a valid session' do
      post :create, admin_session.merge(type: 1)
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode.should_not be_nil
      DecoderLog.first.decode_type.should eq(1)
    end

    it 'should create a decode for a Advanced decode type' do
      post :create, admin_session.merge(type: 2)
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode_type.should eq(2)
    end

    it 'should create a decode for an invalid vin' do
      post :create, admin_invalid_vin
      expect(response.status).to be(404)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      Decode.first.successful.should be_false
      DecoderLog.first.decode_type.should eq(2)
    end

    it 'should not create a decode for an invalid auth_token' do
      post :create, admin_invalid_session
      expect(response.status).to be(403)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end
  end

  describe 'Bronze User' do

    it 'should create a basic Decode for a valid session' do
      post :create, bronze_session
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode.should_not be_nil
      DecoderLog.first.decode_type.should eq(1)
    end

    it 'should fail to create a decode for a Advanced decode type' do
      post :create, bronze_session.merge(type: 2)
      expect(response.status).to be(401)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end

    it 'should create a decode for an invalid vin' do
      post :create, bronze_invalid_vin
      expect(response.status).to be(404)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      Decode.first.successful.should be_false
      DecoderLog.first.decode_type.should eq(1)
    end

    it 'should not create a decode for an invalid auth_token' do
      post :create, bronze_invalid_session
      expect(response.status).to be(403)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end
  end



  describe 'Silver User' do

    it 'should create a basic Decode for a valid session' do
      post :create, silver_session.merge(type: 1)
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode.should_not be_nil
      DecoderLog.first.decode_type.should eq(1)
    end

    it 'should create a decode for a Advanced decode type' do
      post :create, silver_session.merge(type: 2)
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode_type.should eq(2)
    end

    it 'should create a decode for an invalid vin' do
      post :create, silver_invalid_vin.merge(type: 1)
      expect(response.status).to be(404)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      Decode.first.successful.should be_false
      DecoderLog.first.decode_type.should eq(1)
    end

    it 'should not create a decode for an invalid auth_token' do
      post :create, silver_invalid_session.merge(type: 1)
      expect(response.status).to be(403)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end
  end

  describe 'Gold User' do

    it 'should create a basic Decode for a valid session' do
      post :create, gold_session.merge(type: 1)
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode.should_not be_nil
      DecoderLog.first.decode_type.should eq(1)
    end

    it 'should create a decode for a Advanced decode type' do
      post :create, gold_session
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode_type.should eq(2)
    end

    it 'should create a decode for an invalid vin' do
      post :create, gold_invalid_vin.merge(type: 2)
      expect(response.status).to be(404)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      Decode.first.successful.should be_false
      DecoderLog.first.decode_type.should eq(2)
    end

    it 'should not create a decode for an invalid auth_token' do
      post :create, gold_invalid_session
      expect(response.status).to be(403)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end
  end

  describe 'Platinum User' do

    it 'should create a basic Decode for a valid session' do
      post :create, platinum_session.merge(type:1)
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode.should_not be_nil
      DecoderLog.first.decode_type.should eq(1)
    end

    it 'should create a decode for a Advanced decode type' do
      post :create, platinum_session
      expect(response.status).to be(201)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      DecoderLog.first.decode_type.should eq(2)
    end

    it 'should create a decode for an invalid vin' do
      post :create, platinum_invalid_vin
      expect(response.status).to be(404)
      Decode.count.should eq(1)
      DecoderLog.count.should eq(1)
      Decode.first.successful.should be_false
      DecoderLog.first.decode_type.should eq(2)
    end

    it 'should not create a decode for an invalid auth_token' do
      post :create, platinum_invalid_session
      expect(response.status).to be(403)
      Decode.count.should eq(0)
      DecoderLog.count.should eq(0)
    end
  end

  describe 'GET show for Admin' do
    it 'returns the proper decode as Admin (Basic, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(admin_auth[:auth_token]).id )
      get :show, admin_auth.merge( id: decode.id, format: 'json', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Admin (Advanced, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(admin_auth[:auth_token]).id )
      get :show, admin_auth.merge( id: decode.id, format: 'json', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Admin (Basic, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(admin_auth[:auth_token]).id )
      get :show, admin_auth.merge( id: decode.id, format: 'js', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Admin (Advanced, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(admin_auth[:auth_token]).id )
      get :show, admin_auth.merge( id: decode.id, format: 'js', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Admin (Basic, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(admin_auth[:auth_token]).id )
      get :show, admin_auth.merge( id: decode.id, format: 'xml', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Admin (Advanced, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(admin_auth[:auth_token]).id )
      get :show, admin_auth.merge( id: decode.id, format: 'xml', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('2')
    end
  end

  describe 'GET show for Bronze' do
    it 'returns the proper decode as Bronze (Basic, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(bronze_auth[:auth_token]).id )
      get :show, bronze_auth.merge( id: decode.id, format: 'json', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Bronze (Advanced, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(bronze_auth[:auth_token]).id )
      get :show, bronze_auth.merge( id: decode.id, format: 'json', type: 2 )
      expect(response.status).to be(401)
    end

    it 'returns the proper decode as Bronze (Basic, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(bronze_auth[:auth_token]).id )
      get :show, bronze_auth.merge( id: decode.id, format: 'js', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Bronze (Advanced, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(bronze_auth[:auth_token]).id )
      get :show, bronze_auth.merge( id: decode.id, format: 'js', type: 2 )
      expect(response.status).to be(401)
    end

    it 'returns the proper decode as Bronze (Basic, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(bronze_auth[:auth_token]).id )
      get :show, bronze_auth.merge( id: decode.id, format: 'xml', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Bronze (Advanced, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(bronze_auth[:auth_token]).id )
      get :show, bronze_auth.merge( id: decode.id, format: 'xml', type: 2 )
      expect(response.status).to be(401)
    end
  end

  describe 'GET show for Silver' do
    it 'returns the proper decode as Silver (Basic, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(silver_auth[:auth_token]).id )
      get :show, silver_auth.merge( id: decode.id, format: 'json', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Silver (Advanced, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(silver_auth[:auth_token]).id )
      get :show, silver_auth.merge( id: decode.id, format: 'json', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Silver (Basic, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(silver_auth[:auth_token]).id )
      get :show, silver_auth.merge( id: decode.id, format: 'js', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Silver (Advanced, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(silver_auth[:auth_token]).id )
      get :show, silver_auth.merge( id: decode.id, format: 'js', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Silver (Basic, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(silver_auth[:auth_token]).id )
      get :show, silver_auth.merge( id: decode.id, format: 'xml', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Silver (Advanced, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(silver_auth[:auth_token]).id )
      get :show, silver_auth.merge( id: decode.id, format: 'xml', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('2')
    end
  end

  describe 'GET show for Gold' do
    it 'returns the proper decode as Gold (Basic, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(gold_auth[:auth_token]).id )
      get :show, gold_auth.merge( id: decode.id, format: 'json', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Gold (Advanced, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(gold_auth[:auth_token]).id )
      get :show, gold_auth.merge( id: decode.id, format: 'json', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Gold (Basic, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.for_auth(gold_auth[:auth_token]).id )
      get :show, gold_auth.merge( id: decode.id, format: 'js', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Gold (Advanced, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: gold_auth[:auth_token]).first.id)
      get :show, gold_auth.merge( id: decode.id, format: 'js', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Gold (Basic, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: gold_auth[:auth_token]).first.id)
      get :show, gold_auth.merge( id: decode.id, format: 'xml', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Gold (Advanced, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: gold_auth[:auth_token]).first.id)
      get :show, gold_auth.merge( id: decode.id, format: 'xml', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('2')
    end
  end

  describe 'GET show for Platinum' do
    it 'returns the proper decode as Platinum (Basic, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: platinum_auth[:auth_token]).first.id)
      get :show, platinum_auth.merge( id: decode.id, format: 'json', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Platinum (Advanced, JSON)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: platinum_auth[:auth_token]).first.id)
      get :show, platinum_auth.merge( id: decode.id, format: 'json', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Platinum (Basic, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: platinum_auth[:auth_token]).first.id)
      get :show, platinum_auth.merge( id: decode.id, format: 'js', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Platinum (Advanced, JSONP)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: platinum_auth[:auth_token]).first.id)
      get :show, platinum_auth.merge( id: decode.id, format: 'js', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = JSON.parse(response.body)
      parsed_body['decode']['type'].should eq('2')
    end

    it 'returns the proper decode as Platinum (Basic, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: platinum_auth[:auth_token]).first.id)
      get :show, platinum_auth.merge( id: decode.id, format: 'xml', type: 1 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('1')
    end

    it 'returns the proper decode as Platinum (Advanced, XML)' do
      decode = Decode.create! valid_attributes.merge(user_id: User.where(authentication_token: platinum_auth[:auth_token]).first.id)
      get :show, platinum_auth.merge( id: decode.id, format: 'xml', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('2')
    end
  end

  describe 'GET Show authorization' do
    it 'should return unauthorized when you request a record you did not create' do
      decode = Decode.create! valid_attributes.merge( user_id: User.for_auth(admin_auth[:auth_token]).id )
      get :show, platinum_auth.merge( id: decode.id, format: 'xml', type: 1 )
      expect(response.status).to be(401)
    end

    it 'should return the result when you request any record as admin' do
      decode = Decode.create! valid_attributes.merge( user_id: User.for_auth(gold_auth[:auth_token]).id )
      get :show, admin_auth.merge( id: decode.id, format: 'xml', type: 2 )
      assigns(:decode).should eq(decode)
      expect(response.status).to be(200)
      parsed_body = Hash.from_xml response.body
      parsed_body['decode']['type'].should eq('2')
    end
  end
end


